# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_targets_ietf_ped_catalog__ped_catalog_peds_targets(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-ped-catalog - based on the path /ped-catalog/peds/targets. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of target SUTs against which the experiments are executed
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__uri','__vendor_ref','__name_ref','__version_ref','__description',)

  _yang_name = 'targets'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    self.__uri = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    self.__vendor_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    self.__name_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    self.__version_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ped-catalog', 'peds', 'targets']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /ped_catalog/peds/targets/id (string)

    YANG Description: SUT identifier
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /ped_catalog/peds/targets/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: SUT identifier
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)


  def _get_uri(self):
    """
    Getter method for uri, mapped from YANG variable /ped_catalog/peds/targets/uri (string)

    YANG Description: Path/URL pointing to the SUT's location
    """
    return self.__uri
      
  def _set_uri(self, v, load=False):
    """
    Setter method for uri, mapped from YANG variable /ped_catalog/peds/targets/uri (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uri is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uri() directly.

    YANG Description: Path/URL pointing to the SUT's location
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uri must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__uri = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uri(self):
    self.__uri = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)


  def _get_vendor_ref(self):
    """
    Getter method for vendor_ref, mapped from YANG variable /ped_catalog/peds/targets/vendor_ref (string)

    YANG Description: Vendor part of the reference
    """
    return self.__vendor_ref
      
  def _set_vendor_ref(self, v, load=False):
    """
    Setter method for vendor_ref, mapped from YANG variable /ped_catalog/peds/targets/vendor_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor_ref() directly.

    YANG Description: Vendor part of the reference
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vendor-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vendor_ref must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__vendor_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vendor_ref(self):
    self.__vendor_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)


  def _get_name_ref(self):
    """
    Getter method for name_ref, mapped from YANG variable /ped_catalog/peds/targets/name_ref (string)

    YANG Description: Name part of the reference
    """
    return self.__name_ref
      
  def _set_name_ref(self, v, load=False):
    """
    Setter method for name_ref, mapped from YANG variable /ped_catalog/peds/targets/name_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name_ref() directly.

    YANG Description: Name part of the reference
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name_ref must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__name_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name_ref(self):
    self.__name_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)


  def _get_version_ref(self):
    """
    Getter method for version_ref, mapped from YANG variable /ped_catalog/peds/targets/version_ref (string)

    YANG Description: Version part of the reference
    """
    return self.__version_ref
      
  def _set_version_ref(self, v, load=False):
    """
    Setter method for version_ref, mapped from YANG variable /ped_catalog/peds/targets/version_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version_ref() directly.

    YANG Description: Version part of the reference
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version_ref must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__version_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version_ref(self):
    self.__version_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /ped_catalog/peds/targets/description (string)

    YANG Description: Generic description text
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /ped_catalog/peds/targets/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Generic description text
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  uri = __builtin__.property(_get_uri, _set_uri)
  vendor_ref = __builtin__.property(_get_vendor_ref, _set_vendor_ref)
  name_ref = __builtin__.property(_get_name_ref, _set_name_ref)
  version_ref = __builtin__.property(_get_version_ref, _set_version_ref)
  description = __builtin__.property(_get_description, _set_description)


  _pyangbind_elements = OrderedDict([('id', id), ('uri', uri), ('vendor_ref', vendor_ref), ('name_ref', name_ref), ('version_ref', version_ref), ('description', description), ])


class yc_probes_ietf_ped_catalog__ped_catalog_peds_experiments_probes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-ped-catalog - based on the path /ped-catalog/peds/experiments/probes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Probes to be used in this experiment
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__container_image','__connection_point_ref','__address',)

  _yang_name = 'probes'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    self.__container_image = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="container-image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    self.__connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    self.__address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ped-catalog', 'peds', 'experiments', 'probes']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /ped_catalog/peds/experiments/probes/id (string)

    YANG Description: Probe identifier
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /ped_catalog/peds/experiments/probes/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Probe identifier
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)


  def _get_container_image(self):
    """
    Getter method for container_image, mapped from YANG variable /ped_catalog/peds/experiments/probes/container_image (string)

    YANG Description: Name of the container image to be used for this probe
    """
    return self.__container_image
      
  def _set_container_image(self, v, load=False):
    """
    Setter method for container_image, mapped from YANG variable /ped_catalog/peds/experiments/probes/container_image (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_container_image is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_container_image() directly.

    YANG Description: Name of the container image to be used for this probe
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="container-image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """container_image must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="container-image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__container_image = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_container_image(self):
    self.__container_image = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="container-image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)


  def _get_connection_point_ref(self):
    """
    Getter method for connection_point_ref, mapped from YANG variable /ped_catalog/peds/experiments/probes/connection_point_ref (string)

    YANG Description: Name of SUT connectin point to which this probe should be connected
    """
    return self.__connection_point_ref
      
  def _set_connection_point_ref(self, v, load=False):
    """
    Setter method for connection_point_ref, mapped from YANG variable /ped_catalog/peds/experiments/probes/connection_point_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_point_ref() directly.

    YANG Description: Name of SUT connectin point to which this probe should be connected
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_point_ref must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_point_ref(self):
    self.__connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)


  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /ped_catalog/peds/experiments/probes/address (string)

    YANG Description: Static address the probe should get on its data iterface (CIDR)
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /ped_catalog/peds/experiments/probes/address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: Static address the probe should get on its data iterface (CIDR)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  container_image = __builtin__.property(_get_container_image, _set_container_image)
  connection_point_ref = __builtin__.property(_get_connection_point_ref, _set_connection_point_ref)
  address = __builtin__.property(_get_address, _set_address)


  _pyangbind_elements = OrderedDict([('id', id), ('container_image', container_image), ('connection_point_ref', connection_point_ref), ('address', address), ])


class yc_vnf_ref_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_vnf_ref(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-ped-catalog - based on the path /ped-catalog/peds/experiments/parameters/vnf-ref. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Reference to a VNF of the SUT.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vendor_ref','__name_ref','__version_ref',)

  _yang_name = 'vnf-ref'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vendor_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor-ref", parent=self, choice=('node-ref', 'vnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    self.__name_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name-ref", parent=self, choice=('node-ref', 'vnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    self.__version_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version-ref", parent=self, choice=('node-ref', 'vnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ped-catalog', 'peds', 'experiments', 'parameters', 'vnf-ref']

  def _get_vendor_ref(self):
    """
    Getter method for vendor_ref, mapped from YANG variable /ped_catalog/peds/experiments/parameters/vnf_ref/vendor_ref (string)

    YANG Description: Vendor part of the reference
    """
    return self.__vendor_ref
      
  def _set_vendor_ref(self, v, load=False):
    """
    Setter method for vendor_ref, mapped from YANG variable /ped_catalog/peds/experiments/parameters/vnf_ref/vendor_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor_ref() directly.

    YANG Description: Vendor part of the reference
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vendor-ref", parent=self, choice=('node-ref', 'vnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vendor_ref must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor-ref", parent=self, choice=('node-ref', 'vnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__vendor_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vendor_ref(self):
    self.__vendor_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor-ref", parent=self, choice=('node-ref', 'vnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)


  def _get_name_ref(self):
    """
    Getter method for name_ref, mapped from YANG variable /ped_catalog/peds/experiments/parameters/vnf_ref/name_ref (string)

    YANG Description: Name part of the reference
    """
    return self.__name_ref
      
  def _set_name_ref(self, v, load=False):
    """
    Setter method for name_ref, mapped from YANG variable /ped_catalog/peds/experiments/parameters/vnf_ref/name_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name_ref() directly.

    YANG Description: Name part of the reference
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name-ref", parent=self, choice=('node-ref', 'vnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name_ref must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name-ref", parent=self, choice=('node-ref', 'vnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__name_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name_ref(self):
    self.__name_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name-ref", parent=self, choice=('node-ref', 'vnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)


  def _get_version_ref(self):
    """
    Getter method for version_ref, mapped from YANG variable /ped_catalog/peds/experiments/parameters/vnf_ref/version_ref (string)

    YANG Description: Version part of the reference
    """
    return self.__version_ref
      
  def _set_version_ref(self, v, load=False):
    """
    Setter method for version_ref, mapped from YANG variable /ped_catalog/peds/experiments/parameters/vnf_ref/version_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version_ref() directly.

    YANG Description: Version part of the reference
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version-ref", parent=self, choice=('node-ref', 'vnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version_ref must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version-ref", parent=self, choice=('node-ref', 'vnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__version_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version_ref(self):
    self.__version_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version-ref", parent=self, choice=('node-ref', 'vnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)

  vendor_ref = __builtin__.property(_get_vendor_ref, _set_vendor_ref)
  name_ref = __builtin__.property(_get_name_ref, _set_name_ref)
  version_ref = __builtin__.property(_get_version_ref, _set_version_ref)

  __choices__ = {'node-ref': {'vnf': ['vendor_ref', 'name_ref', 'version_ref']}}
  _pyangbind_elements = OrderedDict([('vendor_ref', vendor_ref), ('name_ref', name_ref), ('version_ref', version_ref), ])


class yc_cmd_start_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cmd_start(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-ped-catalog - based on the path /ped-catalog/peds/experiments/parameters/cmd-start. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Command(s) executed after node instantiation
  """
  __slots__ = ('_path_helper', '_extmethods', '__scalar','__vector',)

  _yang_name = 'cmd-start'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__scalar = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    self.__vector = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ped-catalog', 'peds', 'experiments', 'parameters', 'cmd-start']

  def _get_scalar(self):
    """
    Getter method for scalar, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cmd_start/scalar (string)

    YANG Description: Single string value
    """
    return self.__scalar
      
  def _set_scalar(self, v, load=False):
    """
    Setter method for scalar, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cmd_start/scalar (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scalar is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scalar() directly.

    YANG Description: Single string value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scalar must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__scalar = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scalar(self):
    self.__scalar = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)


  def _get_vector(self):
    """
    Getter method for vector, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cmd_start/vector (string)

    YANG Description: List of string values
    """
    return self.__vector
      
  def _set_vector(self, v, load=False):
    """
    Setter method for vector, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cmd_start/vector (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vector() directly.

    YANG Description: List of string values
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vector must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__vector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vector(self):
    self.__vector = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)

  scalar = __builtin__.property(_get_scalar, _set_scalar)
  vector = __builtin__.property(_get_vector, _set_vector)

  __choices__ = {'parameter': {'scalar': ['scalar'], 'vector': ['vector']}}
  _pyangbind_elements = OrderedDict([('scalar', scalar), ('vector', vector), ])


class yc_cmd_stop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cmd_stop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-ped-catalog - based on the path /ped-catalog/peds/experiments/parameters/cmd-stop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Command(s) executed before node termination
  """
  __slots__ = ('_path_helper', '_extmethods', '__scalar','__vector',)

  _yang_name = 'cmd-stop'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__scalar = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    self.__vector = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ped-catalog', 'peds', 'experiments', 'parameters', 'cmd-stop']

  def _get_scalar(self):
    """
    Getter method for scalar, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cmd_stop/scalar (string)

    YANG Description: Single string value
    """
    return self.__scalar
      
  def _set_scalar(self, v, load=False):
    """
    Setter method for scalar, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cmd_stop/scalar (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scalar is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scalar() directly.

    YANG Description: Single string value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scalar must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__scalar = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scalar(self):
    self.__scalar = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)


  def _get_vector(self):
    """
    Getter method for vector, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cmd_stop/vector (string)

    YANG Description: List of string values
    """
    return self.__vector
      
  def _set_vector(self, v, load=False):
    """
    Setter method for vector, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cmd_stop/vector (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vector() directly.

    YANG Description: List of string values
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vector must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__vector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vector(self):
    self.__vector = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)

  scalar = __builtin__.property(_get_scalar, _set_scalar)
  vector = __builtin__.property(_get_vector, _set_vector)

  __choices__ = {'parameter': {'scalar': ['scalar'], 'vector': ['vector']}}
  _pyangbind_elements = OrderedDict([('scalar', scalar), ('vector', vector), ])


class yc_loop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cpu_bw_loop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-ped-catalog - based on the path /ped-catalog/peds/experiments/parameters/cpu-bw/loop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Loop that generates a list of numeric values
  """
  __slots__ = ('_path_helper', '_extmethods', '__begin','__end','__step',)

  _yang_name = 'loop'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__begin = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="begin", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    self.__end = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="end", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    self.__step = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="step", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ped-catalog', 'peds', 'experiments', 'parameters', 'cpu-bw', 'loop']

  def _get_begin(self):
    """
    Getter method for begin, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cpu_bw/loop/begin (decimal64)

    YANG Description: Start value of the loop
    """
    return self.__begin
      
  def _set_begin(self, v, load=False):
    """
    Setter method for begin, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cpu_bw/loop/begin (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_begin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_begin() directly.

    YANG Description: Start value of the loop
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="begin", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """begin must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="begin", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)""",
        })

    self.__begin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_begin(self):
    self.__begin = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="begin", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)


  def _get_end(self):
    """
    Getter method for end, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cpu_bw/loop/end (decimal64)

    YANG Description: Stop value of the loop
    """
    return self.__end
      
  def _set_end(self, v, load=False):
    """
    Setter method for end, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cpu_bw/loop/end (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end() directly.

    YANG Description: Stop value of the loop
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="end", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="end", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)""",
        })

    self.__end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end(self):
    self.__end = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="end", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)


  def _get_step(self):
    """
    Getter method for step, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cpu_bw/loop/step (decimal64)

    YANG Description: Step size of the loop
    """
    return self.__step
      
  def _set_step(self, v, load=False):
    """
    Setter method for step, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cpu_bw/loop/step (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_step is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_step() directly.

    YANG Description: Step size of the loop
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="step", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """step must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="step", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)""",
        })

    self.__step = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_step(self):
    self.__step = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="step", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)

  begin = __builtin__.property(_get_begin, _set_begin)
  end = __builtin__.property(_get_end, _set_end)
  step = __builtin__.property(_get_step, _set_step)

  __choices__ = {'parameter': {'loop': ['begin', 'end', 'step']}}
  _pyangbind_elements = OrderedDict([('begin', begin), ('end', end), ('step', step), ])


class yc_cpu_bw_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cpu_bw(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-ped-catalog - based on the path /ped-catalog/peds/experiments/parameters/cpu-bw. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: CPU bandwidth (CPU time fraction 0...1.0)
  """
  __slots__ = ('_path_helper', '_extmethods', '__scalar','__vector','__loop',)

  _yang_name = 'cpu-bw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__scalar = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    self.__vector = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedPrecisionDecimalType(precision=4)), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    self.__loop = YANGDynClass(base=yc_loop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cpu_bw_loop, is_container='container', yang_name="loop", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ped-catalog', 'peds', 'experiments', 'parameters', 'cpu-bw']

  def _get_scalar(self):
    """
    Getter method for scalar, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cpu_bw/scalar (decimal64)

    YANG Description: Single numeric value
    """
    return self.__scalar
      
  def _set_scalar(self, v, load=False):
    """
    Setter method for scalar, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cpu_bw/scalar (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scalar is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scalar() directly.

    YANG Description: Single numeric value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scalar must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)""",
        })

    self.__scalar = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scalar(self):
    self.__scalar = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)


  def _get_vector(self):
    """
    Getter method for vector, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cpu_bw/vector (decimal64)

    YANG Description: List of numeric values
    """
    return self.__vector
      
  def _set_vector(self, v, load=False):
    """
    Setter method for vector, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cpu_bw/vector (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vector() directly.

    YANG Description: List of numeric values
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedPrecisionDecimalType(precision=4)), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vector must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedPrecisionDecimalType(precision=4)), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)""",
        })

    self.__vector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vector(self):
    self.__vector = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedPrecisionDecimalType(precision=4)), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)


  def _get_loop(self):
    """
    Getter method for loop, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cpu_bw/loop (container)

    YANG Description: Loop that generates a list of numeric values
    """
    return self.__loop
      
  def _set_loop(self, v, load=False):
    """
    Setter method for loop, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cpu_bw/loop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loop() directly.

    YANG Description: Loop that generates a list of numeric values
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_loop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cpu_bw_loop, is_container='container', yang_name="loop", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_loop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cpu_bw_loop, is_container='container', yang_name="loop", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)""",
        })

    self.__loop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loop(self):
    self.__loop = YANGDynClass(base=yc_loop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cpu_bw_loop, is_container='container', yang_name="loop", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)

  scalar = __builtin__.property(_get_scalar, _set_scalar)
  vector = __builtin__.property(_get_vector, _set_vector)
  loop = __builtin__.property(_get_loop, _set_loop)

  __choices__ = {'parameter': {'scalar': ['scalar'], 'vector': ['vector'], 'loop': ['loop']}}
  _pyangbind_elements = OrderedDict([('scalar', scalar), ('vector', vector), ('loop', loop), ])


class yc_cpu_core_set_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cpu_core_set(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-ped-catalog - based on the path /ped-catalog/peds/experiments/parameters/cpu-core-set. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: CPU core set to be used, e.g., core 1 and 3: '1,3'
  """
  __slots__ = ('_path_helper', '_extmethods', '__scalar','__vector',)

  _yang_name = 'cpu-core-set'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__scalar = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    self.__vector = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ped-catalog', 'peds', 'experiments', 'parameters', 'cpu-core-set']

  def _get_scalar(self):
    """
    Getter method for scalar, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cpu_core_set/scalar (string)

    YANG Description: Single string value
    """
    return self.__scalar
      
  def _set_scalar(self, v, load=False):
    """
    Setter method for scalar, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cpu_core_set/scalar (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scalar is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scalar() directly.

    YANG Description: Single string value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scalar must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__scalar = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scalar(self):
    self.__scalar = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)


  def _get_vector(self):
    """
    Getter method for vector, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cpu_core_set/vector (string)

    YANG Description: List of string values
    """
    return self.__vector
      
  def _set_vector(self, v, load=False):
    """
    Setter method for vector, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cpu_core_set/vector (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vector() directly.

    YANG Description: List of string values
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vector must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__vector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vector(self):
    self.__vector = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)

  scalar = __builtin__.property(_get_scalar, _set_scalar)
  vector = __builtin__.property(_get_vector, _set_vector)

  __choices__ = {'parameter': {'scalar': ['scalar'], 'vector': ['vector']}}
  _pyangbind_elements = OrderedDict([('scalar', scalar), ('vector', vector), ])


class yc_loop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_mem_max_loop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-ped-catalog - based on the path /ped-catalog/peds/experiments/parameters/mem-max/loop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Loop that generates a list of numeric values
  """
  __slots__ = ('_path_helper', '_extmethods', '__begin','__end','__step',)

  _yang_name = 'loop'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__begin = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="begin", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    self.__end = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="end", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    self.__step = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="step", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ped-catalog', 'peds', 'experiments', 'parameters', 'mem-max', 'loop']

  def _get_begin(self):
    """
    Getter method for begin, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_max/loop/begin (decimal64)

    YANG Description: Start value of the loop
    """
    return self.__begin
      
  def _set_begin(self, v, load=False):
    """
    Setter method for begin, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_max/loop/begin (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_begin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_begin() directly.

    YANG Description: Start value of the loop
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="begin", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """begin must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="begin", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)""",
        })

    self.__begin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_begin(self):
    self.__begin = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="begin", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)


  def _get_end(self):
    """
    Getter method for end, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_max/loop/end (decimal64)

    YANG Description: Stop value of the loop
    """
    return self.__end
      
  def _set_end(self, v, load=False):
    """
    Setter method for end, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_max/loop/end (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end() directly.

    YANG Description: Stop value of the loop
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="end", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="end", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)""",
        })

    self.__end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end(self):
    self.__end = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="end", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)


  def _get_step(self):
    """
    Getter method for step, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_max/loop/step (decimal64)

    YANG Description: Step size of the loop
    """
    return self.__step
      
  def _set_step(self, v, load=False):
    """
    Setter method for step, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_max/loop/step (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_step is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_step() directly.

    YANG Description: Step size of the loop
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="step", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """step must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="step", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)""",
        })

    self.__step = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_step(self):
    self.__step = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="step", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)

  begin = __builtin__.property(_get_begin, _set_begin)
  end = __builtin__.property(_get_end, _set_end)
  step = __builtin__.property(_get_step, _set_step)

  __choices__ = {'parameter': {'loop': ['begin', 'end', 'step']}}
  _pyangbind_elements = OrderedDict([('begin', begin), ('end', end), ('step', step), ])


class yc_mem_max_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_mem_max(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-ped-catalog - based on the path /ped-catalog/peds/experiments/parameters/mem-max. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Memory limit in MB
  """
  __slots__ = ('_path_helper', '_extmethods', '__scalar','__vector','__loop',)

  _yang_name = 'mem-max'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__scalar = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    self.__vector = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedPrecisionDecimalType(precision=4)), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    self.__loop = YANGDynClass(base=yc_loop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_mem_max_loop, is_container='container', yang_name="loop", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ped-catalog', 'peds', 'experiments', 'parameters', 'mem-max']

  def _get_scalar(self):
    """
    Getter method for scalar, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_max/scalar (decimal64)

    YANG Description: Single numeric value
    """
    return self.__scalar
      
  def _set_scalar(self, v, load=False):
    """
    Setter method for scalar, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_max/scalar (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scalar is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scalar() directly.

    YANG Description: Single numeric value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scalar must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)""",
        })

    self.__scalar = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scalar(self):
    self.__scalar = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)


  def _get_vector(self):
    """
    Getter method for vector, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_max/vector (decimal64)

    YANG Description: List of numeric values
    """
    return self.__vector
      
  def _set_vector(self, v, load=False):
    """
    Setter method for vector, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_max/vector (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vector() directly.

    YANG Description: List of numeric values
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedPrecisionDecimalType(precision=4)), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vector must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedPrecisionDecimalType(precision=4)), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)""",
        })

    self.__vector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vector(self):
    self.__vector = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedPrecisionDecimalType(precision=4)), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)


  def _get_loop(self):
    """
    Getter method for loop, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_max/loop (container)

    YANG Description: Loop that generates a list of numeric values
    """
    return self.__loop
      
  def _set_loop(self, v, load=False):
    """
    Setter method for loop, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_max/loop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loop() directly.

    YANG Description: Loop that generates a list of numeric values
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_loop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_mem_max_loop, is_container='container', yang_name="loop", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_loop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_mem_max_loop, is_container='container', yang_name="loop", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)""",
        })

    self.__loop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loop(self):
    self.__loop = YANGDynClass(base=yc_loop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_mem_max_loop, is_container='container', yang_name="loop", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)

  scalar = __builtin__.property(_get_scalar, _set_scalar)
  vector = __builtin__.property(_get_vector, _set_vector)
  loop = __builtin__.property(_get_loop, _set_loop)

  __choices__ = {'parameter': {'scalar': ['scalar'], 'vector': ['vector'], 'loop': ['loop']}}
  _pyangbind_elements = OrderedDict([('scalar', scalar), ('vector', vector), ('loop', loop), ])


class yc_loop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_mem_swap_max_loop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-ped-catalog - based on the path /ped-catalog/peds/experiments/parameters/mem-swap-max/loop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Loop that generates a list of numeric values
  """
  __slots__ = ('_path_helper', '_extmethods', '__begin','__end','__step',)

  _yang_name = 'loop'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__begin = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="begin", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    self.__end = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="end", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    self.__step = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="step", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ped-catalog', 'peds', 'experiments', 'parameters', 'mem-swap-max', 'loop']

  def _get_begin(self):
    """
    Getter method for begin, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_swap_max/loop/begin (decimal64)

    YANG Description: Start value of the loop
    """
    return self.__begin
      
  def _set_begin(self, v, load=False):
    """
    Setter method for begin, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_swap_max/loop/begin (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_begin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_begin() directly.

    YANG Description: Start value of the loop
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="begin", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """begin must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="begin", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)""",
        })

    self.__begin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_begin(self):
    self.__begin = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="begin", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)


  def _get_end(self):
    """
    Getter method for end, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_swap_max/loop/end (decimal64)

    YANG Description: Stop value of the loop
    """
    return self.__end
      
  def _set_end(self, v, load=False):
    """
    Setter method for end, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_swap_max/loop/end (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end() directly.

    YANG Description: Stop value of the loop
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="end", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="end", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)""",
        })

    self.__end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end(self):
    self.__end = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="end", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)


  def _get_step(self):
    """
    Getter method for step, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_swap_max/loop/step (decimal64)

    YANG Description: Step size of the loop
    """
    return self.__step
      
  def _set_step(self, v, load=False):
    """
    Setter method for step, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_swap_max/loop/step (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_step is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_step() directly.

    YANG Description: Step size of the loop
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="step", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """step must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="step", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)""",
        })

    self.__step = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_step(self):
    self.__step = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="step", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)

  begin = __builtin__.property(_get_begin, _set_begin)
  end = __builtin__.property(_get_end, _set_end)
  step = __builtin__.property(_get_step, _set_step)

  __choices__ = {'parameter': {'loop': ['begin', 'end', 'step']}}
  _pyangbind_elements = OrderedDict([('begin', begin), ('end', end), ('step', step), ])


class yc_mem_swap_max_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_mem_swap_max(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-ped-catalog - based on the path /ped-catalog/peds/experiments/parameters/mem-swap-max. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Momory swap limit in MB (not implemented yet)
  """
  __slots__ = ('_path_helper', '_extmethods', '__scalar','__vector','__loop',)

  _yang_name = 'mem-swap-max'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__scalar = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    self.__vector = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedPrecisionDecimalType(precision=4)), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    self.__loop = YANGDynClass(base=yc_loop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_mem_swap_max_loop, is_container='container', yang_name="loop", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ped-catalog', 'peds', 'experiments', 'parameters', 'mem-swap-max']

  def _get_scalar(self):
    """
    Getter method for scalar, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_swap_max/scalar (decimal64)

    YANG Description: Single numeric value
    """
    return self.__scalar
      
  def _set_scalar(self, v, load=False):
    """
    Setter method for scalar, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_swap_max/scalar (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scalar is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scalar() directly.

    YANG Description: Single numeric value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scalar must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)""",
        })

    self.__scalar = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scalar(self):
    self.__scalar = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)


  def _get_vector(self):
    """
    Getter method for vector, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_swap_max/vector (decimal64)

    YANG Description: List of numeric values
    """
    return self.__vector
      
  def _set_vector(self, v, load=False):
    """
    Setter method for vector, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_swap_max/vector (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vector() directly.

    YANG Description: List of numeric values
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedPrecisionDecimalType(precision=4)), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vector must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedPrecisionDecimalType(precision=4)), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)""",
        })

    self.__vector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vector(self):
    self.__vector = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedPrecisionDecimalType(precision=4)), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)


  def _get_loop(self):
    """
    Getter method for loop, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_swap_max/loop (container)

    YANG Description: Loop that generates a list of numeric values
    """
    return self.__loop
      
  def _set_loop(self, v, load=False):
    """
    Setter method for loop, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_swap_max/loop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loop() directly.

    YANG Description: Loop that generates a list of numeric values
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_loop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_mem_swap_max_loop, is_container='container', yang_name="loop", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_loop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_mem_swap_max_loop, is_container='container', yang_name="loop", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)""",
        })

    self.__loop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loop(self):
    self.__loop = YANGDynClass(base=yc_loop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_mem_swap_max_loop, is_container='container', yang_name="loop", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)

  scalar = __builtin__.property(_get_scalar, _set_scalar)
  vector = __builtin__.property(_get_vector, _set_vector)
  loop = __builtin__.property(_get_loop, _set_loop)

  __choices__ = {'parameter': {'scalar': ['scalar'], 'vector': ['vector'], 'loop': ['loop']}}
  _pyangbind_elements = OrderedDict([('scalar', scalar), ('vector', vector), ('loop', loop), ])


class yc_loop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_io_bw_loop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-ped-catalog - based on the path /ped-catalog/peds/experiments/parameters/io-bw/loop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Loop that generates a list of numeric values
  """
  __slots__ = ('_path_helper', '_extmethods', '__begin','__end','__step',)

  _yang_name = 'loop'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__begin = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="begin", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    self.__end = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="end", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    self.__step = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="step", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ped-catalog', 'peds', 'experiments', 'parameters', 'io-bw', 'loop']

  def _get_begin(self):
    """
    Getter method for begin, mapped from YANG variable /ped_catalog/peds/experiments/parameters/io_bw/loop/begin (decimal64)

    YANG Description: Start value of the loop
    """
    return self.__begin
      
  def _set_begin(self, v, load=False):
    """
    Setter method for begin, mapped from YANG variable /ped_catalog/peds/experiments/parameters/io_bw/loop/begin (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_begin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_begin() directly.

    YANG Description: Start value of the loop
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="begin", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """begin must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="begin", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)""",
        })

    self.__begin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_begin(self):
    self.__begin = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="begin", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)


  def _get_end(self):
    """
    Getter method for end, mapped from YANG variable /ped_catalog/peds/experiments/parameters/io_bw/loop/end (decimal64)

    YANG Description: Stop value of the loop
    """
    return self.__end
      
  def _set_end(self, v, load=False):
    """
    Setter method for end, mapped from YANG variable /ped_catalog/peds/experiments/parameters/io_bw/loop/end (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end() directly.

    YANG Description: Stop value of the loop
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="end", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="end", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)""",
        })

    self.__end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end(self):
    self.__end = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="end", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)


  def _get_step(self):
    """
    Getter method for step, mapped from YANG variable /ped_catalog/peds/experiments/parameters/io_bw/loop/step (decimal64)

    YANG Description: Step size of the loop
    """
    return self.__step
      
  def _set_step(self, v, load=False):
    """
    Setter method for step, mapped from YANG variable /ped_catalog/peds/experiments/parameters/io_bw/loop/step (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_step is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_step() directly.

    YANG Description: Step size of the loop
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="step", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """step must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="step", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)""",
        })

    self.__step = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_step(self):
    self.__step = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="step", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)

  begin = __builtin__.property(_get_begin, _set_begin)
  end = __builtin__.property(_get_end, _set_end)
  step = __builtin__.property(_get_step, _set_step)

  __choices__ = {'parameter': {'loop': ['begin', 'end', 'step']}}
  _pyangbind_elements = OrderedDict([('begin', begin), ('end', end), ('step', step), ])


class yc_io_bw_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_io_bw(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-ped-catalog - based on the path /ped-catalog/peds/experiments/parameters/io-bw. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IO bandwidth limit (not implemented yet)
  """
  __slots__ = ('_path_helper', '_extmethods', '__scalar','__vector','__loop',)

  _yang_name = 'io-bw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__scalar = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    self.__vector = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedPrecisionDecimalType(precision=4)), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    self.__loop = YANGDynClass(base=yc_loop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_io_bw_loop, is_container='container', yang_name="loop", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ped-catalog', 'peds', 'experiments', 'parameters', 'io-bw']

  def _get_scalar(self):
    """
    Getter method for scalar, mapped from YANG variable /ped_catalog/peds/experiments/parameters/io_bw/scalar (decimal64)

    YANG Description: Single numeric value
    """
    return self.__scalar
      
  def _set_scalar(self, v, load=False):
    """
    Setter method for scalar, mapped from YANG variable /ped_catalog/peds/experiments/parameters/io_bw/scalar (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scalar is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scalar() directly.

    YANG Description: Single numeric value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scalar must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)""",
        })

    self.__scalar = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scalar(self):
    self.__scalar = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="scalar", parent=self, choice=('parameter', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)


  def _get_vector(self):
    """
    Getter method for vector, mapped from YANG variable /ped_catalog/peds/experiments/parameters/io_bw/vector (decimal64)

    YANG Description: List of numeric values
    """
    return self.__vector
      
  def _set_vector(self, v, load=False):
    """
    Setter method for vector, mapped from YANG variable /ped_catalog/peds/experiments/parameters/io_bw/vector (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vector() directly.

    YANG Description: List of numeric values
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedPrecisionDecimalType(precision=4)), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vector must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedPrecisionDecimalType(precision=4)), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)""",
        })

    self.__vector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vector(self):
    self.__vector = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedPrecisionDecimalType(precision=4)), is_leaf=False, yang_name="vector", parent=self, choice=('parameter', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)


  def _get_loop(self):
    """
    Getter method for loop, mapped from YANG variable /ped_catalog/peds/experiments/parameters/io_bw/loop (container)

    YANG Description: Loop that generates a list of numeric values
    """
    return self.__loop
      
  def _set_loop(self, v, load=False):
    """
    Setter method for loop, mapped from YANG variable /ped_catalog/peds/experiments/parameters/io_bw/loop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loop() directly.

    YANG Description: Loop that generates a list of numeric values
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_loop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_io_bw_loop, is_container='container', yang_name="loop", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_loop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_io_bw_loop, is_container='container', yang_name="loop", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)""",
        })

    self.__loop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loop(self):
    self.__loop = YANGDynClass(base=yc_loop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_io_bw_loop, is_container='container', yang_name="loop", parent=self, choice=('parameter', 'loop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)

  scalar = __builtin__.property(_get_scalar, _set_scalar)
  vector = __builtin__.property(_get_vector, _set_vector)
  loop = __builtin__.property(_get_loop, _set_loop)

  __choices__ = {'parameter': {'scalar': ['scalar'], 'vector': ['vector'], 'loop': ['loop']}}
  _pyangbind_elements = OrderedDict([('scalar', scalar), ('vector', vector), ('loop', loop), ])


class yc_parameters_ietf_ped_catalog__ped_catalog_peds_experiments_parameters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-ped-catalog - based on the path /ped-catalog/peds/experiments/parameters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters (e.g. configurations) tested during an experiment
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__vnf_ref','__probe_ref','__cmd_start','__cmd_stop','__cpu_bw','__cpu_core_set','__mem_max','__mem_swap_max','__io_bw',)

  _yang_name = 'parameters'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    self.__vnf_ref = YANGDynClass(base=yc_vnf_ref_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_vnf_ref, is_container='container', yang_name="vnf-ref", parent=self, choice=('node-ref', 'vnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)
    self.__probe_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="probe-ref", parent=self, choice=('node-ref', 'probe'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='leafref', is_config=True)
    self.__cmd_start = YANGDynClass(base=yc_cmd_start_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cmd_start, is_container='container', yang_name="cmd-start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)
    self.__cmd_stop = YANGDynClass(base=yc_cmd_stop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cmd_stop, is_container='container', yang_name="cmd-stop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)
    self.__cpu_bw = YANGDynClass(base=yc_cpu_bw_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cpu_bw, is_container='container', yang_name="cpu-bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)
    self.__cpu_core_set = YANGDynClass(base=yc_cpu_core_set_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cpu_core_set, is_container='container', yang_name="cpu-core-set", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)
    self.__mem_max = YANGDynClass(base=yc_mem_max_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_mem_max, is_container='container', yang_name="mem-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)
    self.__mem_swap_max = YANGDynClass(base=yc_mem_swap_max_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_mem_swap_max, is_container='container', yang_name="mem-swap-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)
    self.__io_bw = YANGDynClass(base=yc_io_bw_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_io_bw, is_container='container', yang_name="io-bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ped-catalog', 'peds', 'experiments', 'parameters']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /ped_catalog/peds/experiments/parameters/id (string)

    YANG Description: Identifier
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /ped_catalog/peds/experiments/parameters/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)


  def _get_vnf_ref(self):
    """
    Getter method for vnf_ref, mapped from YANG variable /ped_catalog/peds/experiments/parameters/vnf_ref (container)

    YANG Description: Reference to a VNF of the SUT.
    """
    return self.__vnf_ref
      
  def _set_vnf_ref(self, v, load=False):
    """
    Setter method for vnf_ref, mapped from YANG variable /ped_catalog/peds/experiments/parameters/vnf_ref (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_ref() directly.

    YANG Description: Reference to a VNF of the SUT.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vnf_ref_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_vnf_ref, is_container='container', yang_name="vnf-ref", parent=self, choice=('node-ref', 'vnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnf_ref must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vnf_ref_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_vnf_ref, is_container='container', yang_name="vnf-ref", parent=self, choice=('node-ref', 'vnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)""",
        })

    self.__vnf_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnf_ref(self):
    self.__vnf_ref = YANGDynClass(base=yc_vnf_ref_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_vnf_ref, is_container='container', yang_name="vnf-ref", parent=self, choice=('node-ref', 'vnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)


  def _get_probe_ref(self):
    """
    Getter method for probe_ref, mapped from YANG variable /ped_catalog/peds/experiments/parameters/probe_ref (leafref)

    YANG Description: Reference to a probe ID.
    """
    return self.__probe_ref
      
  def _set_probe_ref(self, v, load=False):
    """
    Setter method for probe_ref, mapped from YANG variable /ped_catalog/peds/experiments/parameters/probe_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_probe_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_probe_ref() directly.

    YANG Description: Reference to a probe ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="probe-ref", parent=self, choice=('node-ref', 'probe'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """probe_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="probe-ref", parent=self, choice=('node-ref', 'probe'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='leafref', is_config=True)""",
        })

    self.__probe_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_probe_ref(self):
    self.__probe_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="probe-ref", parent=self, choice=('node-ref', 'probe'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='leafref', is_config=True)


  def _get_cmd_start(self):
    """
    Getter method for cmd_start, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cmd_start (container)

    YANG Description: Command(s) executed after node instantiation
    """
    return self.__cmd_start
      
  def _set_cmd_start(self, v, load=False):
    """
    Setter method for cmd_start, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cmd_start (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cmd_start is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cmd_start() directly.

    YANG Description: Command(s) executed after node instantiation
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_cmd_start_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cmd_start, is_container='container', yang_name="cmd-start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cmd_start must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_cmd_start_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cmd_start, is_container='container', yang_name="cmd-start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)""",
        })

    self.__cmd_start = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cmd_start(self):
    self.__cmd_start = YANGDynClass(base=yc_cmd_start_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cmd_start, is_container='container', yang_name="cmd-start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)


  def _get_cmd_stop(self):
    """
    Getter method for cmd_stop, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cmd_stop (container)

    YANG Description: Command(s) executed before node termination
    """
    return self.__cmd_stop
      
  def _set_cmd_stop(self, v, load=False):
    """
    Setter method for cmd_stop, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cmd_stop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cmd_stop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cmd_stop() directly.

    YANG Description: Command(s) executed before node termination
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_cmd_stop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cmd_stop, is_container='container', yang_name="cmd-stop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cmd_stop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_cmd_stop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cmd_stop, is_container='container', yang_name="cmd-stop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)""",
        })

    self.__cmd_stop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cmd_stop(self):
    self.__cmd_stop = YANGDynClass(base=yc_cmd_stop_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cmd_stop, is_container='container', yang_name="cmd-stop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)


  def _get_cpu_bw(self):
    """
    Getter method for cpu_bw, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cpu_bw (container)

    YANG Description: CPU bandwidth (CPU time fraction 0...1.0)
    """
    return self.__cpu_bw
      
  def _set_cpu_bw(self, v, load=False):
    """
    Setter method for cpu_bw, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cpu_bw (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_bw is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_bw() directly.

    YANG Description: CPU bandwidth (CPU time fraction 0...1.0)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_cpu_bw_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cpu_bw, is_container='container', yang_name="cpu-bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_bw must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_cpu_bw_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cpu_bw, is_container='container', yang_name="cpu-bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)""",
        })

    self.__cpu_bw = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_bw(self):
    self.__cpu_bw = YANGDynClass(base=yc_cpu_bw_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cpu_bw, is_container='container', yang_name="cpu-bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)


  def _get_cpu_core_set(self):
    """
    Getter method for cpu_core_set, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cpu_core_set (container)

    YANG Description: CPU core set to be used, e.g., core 1 and 3: '1,3'
    """
    return self.__cpu_core_set
      
  def _set_cpu_core_set(self, v, load=False):
    """
    Setter method for cpu_core_set, mapped from YANG variable /ped_catalog/peds/experiments/parameters/cpu_core_set (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_core_set is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_core_set() directly.

    YANG Description: CPU core set to be used, e.g., core 1 and 3: '1,3'
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_cpu_core_set_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cpu_core_set, is_container='container', yang_name="cpu-core-set", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_core_set must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_cpu_core_set_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cpu_core_set, is_container='container', yang_name="cpu-core-set", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)""",
        })

    self.__cpu_core_set = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_core_set(self):
    self.__cpu_core_set = YANGDynClass(base=yc_cpu_core_set_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_cpu_core_set, is_container='container', yang_name="cpu-core-set", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)


  def _get_mem_max(self):
    """
    Getter method for mem_max, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_max (container)

    YANG Description: Memory limit in MB
    """
    return self.__mem_max
      
  def _set_mem_max(self, v, load=False):
    """
    Setter method for mem_max, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_max (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mem_max is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mem_max() directly.

    YANG Description: Memory limit in MB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_mem_max_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_mem_max, is_container='container', yang_name="mem-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mem_max must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_mem_max_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_mem_max, is_container='container', yang_name="mem-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)""",
        })

    self.__mem_max = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mem_max(self):
    self.__mem_max = YANGDynClass(base=yc_mem_max_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_mem_max, is_container='container', yang_name="mem-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)


  def _get_mem_swap_max(self):
    """
    Getter method for mem_swap_max, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_swap_max (container)

    YANG Description: Momory swap limit in MB (not implemented yet)
    """
    return self.__mem_swap_max
      
  def _set_mem_swap_max(self, v, load=False):
    """
    Setter method for mem_swap_max, mapped from YANG variable /ped_catalog/peds/experiments/parameters/mem_swap_max (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mem_swap_max is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mem_swap_max() directly.

    YANG Description: Momory swap limit in MB (not implemented yet)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_mem_swap_max_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_mem_swap_max, is_container='container', yang_name="mem-swap-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mem_swap_max must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_mem_swap_max_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_mem_swap_max, is_container='container', yang_name="mem-swap-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)""",
        })

    self.__mem_swap_max = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mem_swap_max(self):
    self.__mem_swap_max = YANGDynClass(base=yc_mem_swap_max_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_mem_swap_max, is_container='container', yang_name="mem-swap-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)


  def _get_io_bw(self):
    """
    Getter method for io_bw, mapped from YANG variable /ped_catalog/peds/experiments/parameters/io_bw (container)

    YANG Description: IO bandwidth limit (not implemented yet)
    """
    return self.__io_bw
      
  def _set_io_bw(self, v, load=False):
    """
    Setter method for io_bw, mapped from YANG variable /ped_catalog/peds/experiments/parameters/io_bw (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_io_bw is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_io_bw() directly.

    YANG Description: IO bandwidth limit (not implemented yet)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_io_bw_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_io_bw, is_container='container', yang_name="io-bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """io_bw must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_io_bw_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_io_bw, is_container='container', yang_name="io-bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)""",
        })

    self.__io_bw = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_io_bw(self):
    self.__io_bw = YANGDynClass(base=yc_io_bw_ietf_ped_catalog__ped_catalog_peds_experiments_parameters_io_bw, is_container='container', yang_name="io-bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  vnf_ref = __builtin__.property(_get_vnf_ref, _set_vnf_ref)
  probe_ref = __builtin__.property(_get_probe_ref, _set_probe_ref)
  cmd_start = __builtin__.property(_get_cmd_start, _set_cmd_start)
  cmd_stop = __builtin__.property(_get_cmd_stop, _set_cmd_stop)
  cpu_bw = __builtin__.property(_get_cpu_bw, _set_cpu_bw)
  cpu_core_set = __builtin__.property(_get_cpu_core_set, _set_cpu_core_set)
  mem_max = __builtin__.property(_get_mem_max, _set_mem_max)
  mem_swap_max = __builtin__.property(_get_mem_swap_max, _set_mem_swap_max)
  io_bw = __builtin__.property(_get_io_bw, _set_io_bw)

  __choices__ = {'node-ref': {'vnf': ['vnf_ref'], 'probe': ['probe_ref']}}
  _pyangbind_elements = OrderedDict([('id', id), ('vnf_ref', vnf_ref), ('probe_ref', probe_ref), ('cmd_start', cmd_start), ('cmd_stop', cmd_stop), ('cpu_bw', cpu_bw), ('cpu_core_set', cpu_core_set), ('mem_max', mem_max), ('mem_swap_max', mem_swap_max), ('io_bw', io_bw), ])


class yc_experiments_ietf_ped_catalog__ped_catalog_peds_experiments(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-ped-catalog - based on the path /ped-catalog/peds/experiments. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__repetitions','__time_limit','__probes','__parameters',)

  _yang_name = 'experiments'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    self.__repetitions = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="repetitions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='uint64', is_config=True)
    self.__time_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="time-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='time-in-seconds', is_config=True)
    self.__probes = YANGDynClass(base=YANGListType("id",yc_probes_ietf_ped_catalog__ped_catalog_peds_experiments_probes, yang_name="probes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="probes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='list', is_config=True)
    self.__parameters = YANGDynClass(base=YANGListType("id",yc_parameters_ietf_ped_catalog__ped_catalog_peds_experiments_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ped-catalog', 'peds', 'experiments']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /ped_catalog/peds/experiments/id (string)

    YANG Description: Experiment identifier
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /ped_catalog/peds/experiments/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Experiment identifier
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)


  def _get_repetitions(self):
    """
    Getter method for repetitions, mapped from YANG variable /ped_catalog/peds/experiments/repetitions (uint64)

    YANG Description: Number of repetiotions (also called trails)
    """
    return self.__repetitions
      
  def _set_repetitions(self, v, load=False):
    """
    Setter method for repetitions, mapped from YANG variable /ped_catalog/peds/experiments/repetitions (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_repetitions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_repetitions() directly.

    YANG Description: Number of repetiotions (also called trails)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="repetitions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """repetitions must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="repetitions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='uint64', is_config=True)""",
        })

    self.__repetitions = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_repetitions(self):
    self.__repetitions = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="repetitions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='uint64', is_config=True)


  def _get_time_limit(self):
    """
    Getter method for time_limit, mapped from YANG variable /ped_catalog/peds/experiments/time_limit (time-in-seconds)

    YANG Description: Runtime of a single experiment in seconds
    """
    return self.__time_limit
      
  def _set_time_limit(self, v, load=False):
    """
    Setter method for time_limit, mapped from YANG variable /ped_catalog/peds/experiments/time_limit (time-in-seconds)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_time_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_time_limit() directly.

    YANG Description: Runtime of a single experiment in seconds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="time-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='time-in-seconds', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """time_limit must be of a type compatible with time-in-seconds""",
          'defined-type': "ietf-ped-catalog:time-in-seconds",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="time-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='time-in-seconds', is_config=True)""",
        })

    self.__time_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_time_limit(self):
    self.__time_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="time-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='time-in-seconds', is_config=True)


  def _get_probes(self):
    """
    Getter method for probes, mapped from YANG variable /ped_catalog/peds/experiments/probes (list)

    YANG Description: Probes to be used in this experiment
    """
    return self.__probes
      
  def _set_probes(self, v, load=False):
    """
    Setter method for probes, mapped from YANG variable /ped_catalog/peds/experiments/probes (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_probes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_probes() directly.

    YANG Description: Probes to be used in this experiment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_probes_ietf_ped_catalog__ped_catalog_peds_experiments_probes, yang_name="probes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="probes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """probes must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_probes_ietf_ped_catalog__ped_catalog_peds_experiments_probes, yang_name="probes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="probes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='list', is_config=True)""",
        })

    self.__probes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_probes(self):
    self.__probes = YANGDynClass(base=YANGListType("id",yc_probes_ietf_ped_catalog__ped_catalog_peds_experiments_probes, yang_name="probes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="probes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='list', is_config=True)


  def _get_parameters(self):
    """
    Getter method for parameters, mapped from YANG variable /ped_catalog/peds/experiments/parameters (list)

    YANG Description: Parameters (e.g. configurations) tested during an experiment
    """
    return self.__parameters
      
  def _set_parameters(self, v, load=False):
    """
    Setter method for parameters, mapped from YANG variable /ped_catalog/peds/experiments/parameters (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameters() directly.

    YANG Description: Parameters (e.g. configurations) tested during an experiment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_parameters_ietf_ped_catalog__ped_catalog_peds_experiments_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameters must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_parameters_ietf_ped_catalog__ped_catalog_peds_experiments_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='list', is_config=True)""",
        })

    self.__parameters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameters(self):
    self.__parameters = YANGDynClass(base=YANGListType("id",yc_parameters_ietf_ped_catalog__ped_catalog_peds_experiments_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  repetitions = __builtin__.property(_get_repetitions, _set_repetitions)
  time_limit = __builtin__.property(_get_time_limit, _set_time_limit)
  probes = __builtin__.property(_get_probes, _set_probes)
  parameters = __builtin__.property(_get_parameters, _set_parameters)


  _pyangbind_elements = OrderedDict([('id', id), ('repetitions', repetitions), ('time_limit', time_limit), ('probes', probes), ('parameters', parameters), ])


class yc_peds_ietf_ped_catalog__ped_catalog_peds(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-ped-catalog - based on the path /ped-catalog/peds. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of PEDs
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__descriptor_version','__vendor','__name','__version','__description','__author','__targets','__experiments',)

  _yang_name = 'peds'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    self.__descriptor_version = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(1.0), is_leaf=True, yang_name="descriptor-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    self.__vendor = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    self.__author = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="author", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    self.__targets = YANGDynClass(base=YANGListType("id",yc_targets_ietf_ped_catalog__ped_catalog_peds_targets, yang_name="targets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='list', is_config=True)
    self.__experiments = YANGDynClass(base=YANGListType("id",yc_experiments_ietf_ped_catalog__ped_catalog_peds_experiments, yang_name="experiments", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="experiments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ped-catalog', 'peds']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /ped_catalog/peds/id (string)

    YANG Description: PED identifier
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /ped_catalog/peds/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: PED identifier
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)


  def _get_descriptor_version(self):
    """
    Getter method for descriptor_version, mapped from YANG variable /ped_catalog/peds/descriptor_version (decimal64)

    YANG Description: Version of the data model
    """
    return self.__descriptor_version
      
  def _set_descriptor_version(self, v, load=False):
    """
    Setter method for descriptor_version, mapped from YANG variable /ped_catalog/peds/descriptor_version (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_descriptor_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_descriptor_version() directly.

    YANG Description: Version of the data model
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(1.0), is_leaf=True, yang_name="descriptor-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """descriptor_version must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(1.0), is_leaf=True, yang_name="descriptor-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)""",
        })

    self.__descriptor_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_descriptor_version(self):
    self.__descriptor_version = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(1.0), is_leaf=True, yang_name="descriptor-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='decimal64', is_config=True)


  def _get_vendor(self):
    """
    Getter method for vendor, mapped from YANG variable /ped_catalog/peds/vendor (string)

    YANG Description: PED vendor
    """
    return self.__vendor
      
  def _set_vendor(self, v, load=False):
    """
    Setter method for vendor, mapped from YANG variable /ped_catalog/peds/vendor (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor() directly.

    YANG Description: PED vendor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vendor must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__vendor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vendor(self):
    self.__vendor = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ped_catalog/peds/name (string)

    YANG Description: PED name
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ped_catalog/peds/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: PED name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /ped_catalog/peds/version (string)

    YANG Description: PED version
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /ped_catalog/peds/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: PED version
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /ped_catalog/peds/description (string)

    YANG Description: Generic description text
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /ped_catalog/peds/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Generic description text
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)


  def _get_author(self):
    """
    Getter method for author, mapped from YANG variable /ped_catalog/peds/author (string)

    YANG Description: Author of the described experiments
    """
    return self.__author
      
  def _set_author(self, v, load=False):
    """
    Setter method for author, mapped from YANG variable /ped_catalog/peds/author (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_author is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_author() directly.

    YANG Description: Author of the described experiments
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="author", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """author must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="author", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)""",
        })

    self.__author = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_author(self):
    self.__author = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="author", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='string', is_config=True)


  def _get_targets(self):
    """
    Getter method for targets, mapped from YANG variable /ped_catalog/peds/targets (list)

    YANG Description: List of target SUTs against which the experiments are executed
    """
    return self.__targets
      
  def _set_targets(self, v, load=False):
    """
    Setter method for targets, mapped from YANG variable /ped_catalog/peds/targets (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_targets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_targets() directly.

    YANG Description: List of target SUTs against which the experiments are executed
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_targets_ietf_ped_catalog__ped_catalog_peds_targets, yang_name="targets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """targets must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_targets_ietf_ped_catalog__ped_catalog_peds_targets, yang_name="targets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='list', is_config=True)""",
        })

    self.__targets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_targets(self):
    self.__targets = YANGDynClass(base=YANGListType("id",yc_targets_ietf_ped_catalog__ped_catalog_peds_targets, yang_name="targets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='list', is_config=True)


  def _get_experiments(self):
    """
    Getter method for experiments, mapped from YANG variable /ped_catalog/peds/experiments (list)
    """
    return self.__experiments
      
  def _set_experiments(self, v, load=False):
    """
    Setter method for experiments, mapped from YANG variable /ped_catalog/peds/experiments (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_experiments is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_experiments() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_experiments_ietf_ped_catalog__ped_catalog_peds_experiments, yang_name="experiments", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="experiments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """experiments must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_experiments_ietf_ped_catalog__ped_catalog_peds_experiments, yang_name="experiments", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="experiments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='list', is_config=True)""",
        })

    self.__experiments = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_experiments(self):
    self.__experiments = YANGDynClass(base=YANGListType("id",yc_experiments_ietf_ped_catalog__ped_catalog_peds_experiments, yang_name="experiments", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="experiments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  descriptor_version = __builtin__.property(_get_descriptor_version, _set_descriptor_version)
  vendor = __builtin__.property(_get_vendor, _set_vendor)
  name = __builtin__.property(_get_name, _set_name)
  version = __builtin__.property(_get_version, _set_version)
  description = __builtin__.property(_get_description, _set_description)
  author = __builtin__.property(_get_author, _set_author)
  targets = __builtin__.property(_get_targets, _set_targets)
  experiments = __builtin__.property(_get_experiments, _set_experiments)


  _pyangbind_elements = OrderedDict([('id', id), ('descriptor_version', descriptor_version), ('vendor', vendor), ('name', name), ('version', version), ('description', description), ('author', author), ('targets', targets), ('experiments', experiments), ])


class yc_ped_catalog_ietf_ped_catalog__ped_catalog(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-ped-catalog - based on the path /ped-catalog. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Performance Experiment Descriptor (PED)
  """
  __slots__ = ('_path_helper', '_extmethods', '__peds',)

  _yang_name = 'ped-catalog'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peds = YANGDynClass(base=YANGListType("id",yc_peds_ietf_ped_catalog__ped_catalog_peds, yang_name="peds", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="peds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ped-catalog']

  def _get_peds(self):
    """
    Getter method for peds, mapped from YANG variable /ped_catalog/peds (list)

    YANG Description: List of PEDs
    """
    return self.__peds
      
  def _set_peds(self, v, load=False):
    """
    Setter method for peds, mapped from YANG variable /ped_catalog/peds (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peds() directly.

    YANG Description: List of PEDs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_peds_ietf_ped_catalog__ped_catalog_peds, yang_name="peds", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="peds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peds must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_peds_ietf_ped_catalog__ped_catalog_peds, yang_name="peds", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="peds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='list', is_config=True)""",
        })

    self.__peds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peds(self):
    self.__peds = YANGDynClass(base=YANGListType("id",yc_peds_ietf_ped_catalog__ped_catalog_peds, yang_name="peds", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="peds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='list', is_config=True)

  peds = __builtin__.property(_get_peds, _set_peds)


  _pyangbind_elements = OrderedDict([('peds', peds), ])


class ietf_ped_catalog(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-ped-catalog - based on the path /ietf-ped-catalog. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Performance Experiment Descriptor (PED) model
  """
  __slots__ = ('_path_helper', '_extmethods', '__ped_catalog',)

  _yang_name = 'ietf-ped-catalog'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ped_catalog = YANGDynClass(base=yc_ped_catalog_ietf_ped_catalog__ped_catalog, is_container='container', yang_name="ped-catalog", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_ped_catalog(self):
    """
    Getter method for ped_catalog, mapped from YANG variable /ped_catalog (container)

    YANG Description: Performance Experiment Descriptor (PED)
    """
    return self.__ped_catalog
      
  def _set_ped_catalog(self, v, load=False):
    """
    Setter method for ped_catalog, mapped from YANG variable /ped_catalog (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ped_catalog is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ped_catalog() directly.

    YANG Description: Performance Experiment Descriptor (PED)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ped_catalog_ietf_ped_catalog__ped_catalog, is_container='container', yang_name="ped-catalog", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ped_catalog must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ped_catalog_ietf_ped_catalog__ped_catalog, is_container='container', yang_name="ped-catalog", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)""",
        })

    self.__ped_catalog = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ped_catalog(self):
    self.__ped_catalog = YANGDynClass(base=yc_ped_catalog_ietf_ped_catalog__ped_catalog, is_container='container', yang_name="ped-catalog", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ped-catalog', defining_module='ietf-ped-catalog', yang_type='container', is_config=True)

  ped_catalog = __builtin__.property(_get_ped_catalog, _set_ped_catalog)


  _pyangbind_elements = OrderedDict([('ped_catalog', ped_catalog), ])


